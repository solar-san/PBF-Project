---
title: "Project: The Forecasting Tourism 2010 Competition"
subtitle: "EM1415"
author: "Marco Solari, 875475"
format: pdf
papersize: a4
geometry:
  - left=23mm
  - right=35.5mm
  - marginparwidth=23mm
  - top=30mm
  - bottom=30mm
toc: true
highlight-style: breeze
code-block-bg: true

mainfont: 'Atkinson Hyperlegible'
monofont: 'Fira Code'
mathfont: 'Noto Sans Math'
sansfont: RobotoSerifNormalRoman-Medium
fontsize: 9pt        

fig-align: center
fig-width: 10
fig-height: 8
number-sections: true
df-print: kable
tbl-cap-location: bottom

include-in-header: 
  text: |
    \usepackage{fvextra}
    \usepackage{listings}
    \usepackage{lstfiracode}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
    \newfontfamily\sectionfont[]{RobotoSerifNormalRoman-ExtraBold}
    \newfontfamily\subsectionfont[]{RobotoSerifNormalRoman-Medium}
    \newfontfamily\subsubsectionfont[]{RobotoSerifNormalRoman-Medium}
    \addtokomafont{section}{\sectionfont}
    \addtokomafont{subsection}{\subsectionfont}
    \addtokomafont{subsubsection}{\subsubsectionfont}
    \makeatletter
    \def\verbatim@nolig@list{}
    \makeatother

reference-location: margin 
citation-location: margin 
---

------------------------------------------------------------------------

\newpage

# Setup and Data Loading

## Setup

```{r setup, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  echo = T,
  dev = "cairo_pdf"
)

libraries_list <- c(
  "tidyverse",
  "fpp3",
  "ggthemes"
  
)

lapply(
  X = libraries_list,
  FUN = require,
  character.only = TRUE
)

theme_set(
  ggthemes::theme_tufte(
    base_size = 16,
    base_family = "Atkinson Hyperlegible"
  )
)
```

## Loading Data {#sec-dataload}

```{r load data}
data_main <- readr::read_csv(
  "Data/tourism_data.csv",
  show_col_types = F
)
```

```{r checking dimensions and NA 1}
data_main %>% dim
```

```{r checkig dimensions and NA 2}
data_main %>% is.na() %>% sum
```

We are missing `r round(100*(data_main %>% is.na() %>% sum) / (data_main %>% nrow() * data_main %>% ncol()), digits = 2)`% of the observations.

## Creating `tsibble`

```{r creating tourism tsibble}
tourism_full <- data_main %>% 
  mutate(
    Year = 1965:2007
  ) %>% 
  as_tsibble(
    index = Year
  )
```

# Assignment

## Full Plot

### Everything, Everywhere, All At Once

> *Plot all the series (an advanced data visualization tool is recommended) - what type of components are visible? Are the series similar or different? Check for problems such as missing values and possible errors.*

```{r melted tsibble}
tmelt <- reshape2::melt(tourism_full,id="Year")
```

```{r tmelt dim}
tmelt %>% dim()
```

`tmelt` (@tbl-tmelt) contains the *melted* data frame, which allows us to visualize all 518 time series at once.

```{r tmelt head}
#| label: tbl-tmelt
#| echo: false
#| tbl-cap: "Melted `tsibble` containing all time series."
tmelt %>% 
  tail(10)
```

```{r full viz train}
#| label: fig-every
#| fig-cap: "Printing a legend for 518 different series is not possible. However, color has been used only to differentiate the series and does not contain further information. Plotting the y-axis variable on the log scale was made necessary by the huge variation in the series values."
#| fig-width: 12
#| fig-height: 12
tmelt %>% 
  ggplot(
    aes(
      x = Year,
      y = value,
      colour = variable,
      group = variable
      )
    ) + 
  geom_line(
    alpha = .8
  ) + 
  scale_y_log10() +
  scale_color_viridis_d(
    option = "cividis"
  ) +
  labs(
    title = "Tourism Time Series: Everything All At Once",
    y = "Value"
  ) +
  theme(
    legend.position = "none"
    )
```

Plotting all 518 series does not allow to spot details, such as the presence of seasonal patterns. However, a general upward trend is clear; moreover, we can spot some probable outliers, that should be further investigated, and some clues about the presence of cyclicality in some of the series.

A check for `NA`s has already been made while loading data (@sec-dataload) and it showed the presence of a large number of missing values, corresponding to `r round(100*(data_main %>% is.na() %>% sum) / (data_main %>% nrow() * data_main %>% ncol()), digits = 2)` of all observations. While this is mostly to be attributed to the different starting time of the series, we can also see that some time series have missing values occurring between the starting and ending point; hence, some series present missing values *in between* available observations. From the visualization we can definitely group different starting points: this suggests that another approach to visualisation might be successfully conducted by grouping series by their starting date.

```{r binned NAs table}
#| tbl-cap: "Missing observation grouped by time windows."
tmelt %>% 
  mutate(
    Time_Interval = cut(
      Year,
      breaks = c(1964, 1975, 1985, 1995, 2003, 2008)
    )
  ) %>% 
  group_by(Time_Interval) %>% 
  summarise(
    Available_Observations = sum(
      !is.na(value)
      )
  )
```

### Grouped by IQR

```{r quartiles and mean plot}
#| fig-cap: "The following plot represents the position indexes given by the mean and the quartile, computed by considering all the series as observations and discarding missing observations."
#| fig-width: 12
#| fig-height: 10
tmelt %>% 
  mutate(
    Time_Interval = cut(
      Year,
      breaks = c(1964, 1975, 1985, 1995, 2003, 2008)
    )
  ) %>%  
  group_by(Year) %>% 
  mutate(
    median_value = median(value, na.rm = T),
    mean_value = mean(value, na.rm = T),
    q_0.25 = quantile(value, probs = .25, na.rm = T),
    q_0.75 = quantile(value, probs = .75, na.rm = T)
  ) %>% 
  ggplot(
    aes(
      x = Year
      )
    ) + 
  geom_line(
    aes(
      y = mean_value,
    color = viridisLite::cividis(1, begin = 1),
    ),
    linewidth = 1,
    linetype = "dotted"
  ) + 
  geom_line(
    aes(
      y = median_value,
    color = viridisLite::cividis(1, begin = .5)
    ),
    linewidth = 1
  ) + 
  geom_line(
    aes(
      y = q_0.25,
    color = viridisLite::cividis(1, begin = .25)
    ),
    linewidth = 1
  ) + 
  geom_line(
    aes(
      y = q_0.75,
    color = viridisLite::cividis(1, begin = .75)
    ),
    linewidth = 1
  ) + 
  geom_ribbon(
    aes(
      ymin = q_0.25,
      ymax = q_0.75,
    ),
    fill = "grey95",
    alpha = .5
  ) +
  scale_y_log10()  +
  scale_color_viridis_d(
    labels = c(
      expression(q[0.25]),
      expression(q[0.50]),
      expression(q[0.75]),
      expression(mu)
      ),
    option = "cividis",
    direction = -1,
    end = .9
  ) +
  labs(
    title = "Tourism Time Series: Quartiles and Mean",
    y = "Value",
    colour = "Index"
  )
```

### Plotting Series By Starting Year

```{r}
#| fig-cap: "The following plot represents the position indexes given by the mean and the quartile, computed by considering all the series as observations and discarding missing observations."
#| fig-width: 12
#| fig-height: 20

tmelt %>% 
  group_by(variable) %>% 
  mutate(series_length = 43-  value %>% is.na %>% sum) %>% 
  ungroup() %>% 
  arrange(desc(series_length)) %>% 
  mutate(series_length = as_factor(series_length)) %>% 
  ggplot(
    aes(x = Year)
  ) +
  facet_wrap(
    ~series_length,
    nrow = 6,
    ncol = 3,
    scales = "free"
  ) +
  geom_line(
    aes(
      y = value,
      color = variable
    )
  ) +
  scale_y_log10() +
  scale_color_viridis_d(
    option = "cividis"
  ) +
  theme(
    legend.position = "none"
  )
```



## Creating Validation Set

> *Partition the series into training and validation, so that the last 4 years are in the validation period for each series. What is the logic of such a partitioning? What is the disadvantage?*

```{r creating train and test split}
train <- tourism_full %>% 
  filter(Year < 2004)
validation <- tourism_full %>% 
  filter(Year >= 2004)
```

The logic behind partitioning the series into a *training* and *validation* set is to *estimate the forecasting error*: we can train a model or apply a filter to the train set and use it to assess its performance with out-of-sample data. The main disadvantage with this approach is that we are not using all the information available to train our model; moreover, we are not computing *true forecasts*, therefore the accuracy measures from the residuals will be smaller.

## Naïve Forecasts

> *Generate naïve forecasts for all series for the validation period. For each series, create forecasts with horizons of 1, 2, 3, and 4 years ahead (*$F_{t+1}, F_{t+2}, F_{t+3}$, and $F_{t+4}$).

We know that *naïve* forecasts consist in the last observation, $\forall h$.

$$
\tag{1}
y_{T + h \ | \ T} = y_T
$$ {#eq-naive}

It follows that we can produce the forecasts with the following code:

```{r naive forecast at 1}
naive_forecast <- train %>% 
  filter(
    Year == 2003
  ) %>% as_tibble()
```

`naive_forecast` will contain a `tsibble` with $y_t$ for all the series.

```{r checking dimensions}
naive_forecast %>% dim
```

To obtain $F_{t+1}, F_{t+2}, F_{t+3}$, and $F_{t+4}$:

```{r all naive forecasts tsibble}
naive_2004_2007 <- merge(
    x = 2003 + 1:4,
    y = naive_forecast
  ) %>% 
  mutate(
    Year = x
  ) %>% 
  select(
    -x
  ) %>% 
  as_tsibble(
    index = Year
  )
```

## Choosing Measures

> *Which measures are suitable if we plan to combine the results for the 518 series? Consider MAE, Average error, MAPE and RMSE.*

## Computing MAPE

> *For each series, compute MAPE of the naive forecasts once for the training period and once for the validation period.*

### Training Period:

It follows from the definition of *naïve forecasts* (@eq-naive) that what is needed to compute the MAPE for all the training dataset is just a modified version of it in which all rows change their position by 1. The last forecast can be added by binding it to maintain the same dimensions and have a full forecast matrix.

```{r training NAIVE forecasts}
train_forecasts <- train %>% 
  select(-Year) %>% 
  as_tibble()
first_forecast <- rep(
  NA,
  518
)
naive_train <- rbind(
  c(
    rep(
      NA,
      dim(train_forecasts)[2]
      )
  ),
  train_forecasts[1:(dim(train_forecasts)[1] -1), ]
)
```

```{r phat training naive}
uhat_full <- naive_train - train
p_uhat_full <- uhat_full/train
```

```{r NAIVE training MAPE}
mape_training <-  100*apply(
    X = p_uhat_full %>% select(-Year),
    FUN = mean,
    MARGIN = 2,
    na.rm = T
  )
```

```{r dim check training MAPE array}
mape_training %>% length
```

### Validation Period:

```{r computing validation residuals}
uhat_validation <- naive_2004_2007 - validation
p_uhat <- uhat_validation/validation
```

```{r MAPE validation}
mape_validation <-  100*apply(
    X = p_uhat %>% select(-Year),
    FUN = mean,
    MARGIN = 2,
    na.rm = T
  )
```

```{r dim check validation MAPE array}
mape_validation %>% length
```

### Comparison Table

```{r prettyprint MAPEs comparison table}
#| tbl-cap: "Naïve forecasts training and MAPEs for the first 10 time series."
bind_rows(
mape_training[1:10] %>% 
  round(., digits = 2) %>% 
  t() %>% 
  as_tibble() %>% 
  mutate(
    Set = "Training",
    .before = Y1
  ) %>% 
  tail(),
mape_validation[1:10] %>% 
  round(., digits = 2) %>% 
  t() %>% 
  as_tibble() %>% 
  mutate(
    Set = "Validation"
  )
)
```


```{r}

```


## Computing MASE

> *The performance measure used in the competition is Mean Absolute Scaled Error (MASE). Explain the advantage of MASE and compute the training and validation MASE for the naive forecasts.*

### Training Period:

```{r qhat training set}
qhat_training <- (dim(uhat_full)[1] - 1) * uhat_full / sum(abs(uhat_full), na.rm = T)
```

```{r MASE training}
mase_training <- apply(
    X = qhat_training %>% select(-Year),
    FUN = mean,
    MARGIN = 2,
    na.rm = T
  )
```

```{r dim check training MASE array}
mase_training %>% length
```

This is the MASE for the first 10 series.

### Validation Period:

```{r qhat validation set}
qhat_validation <- (dim(uhat_validation)[1] - 1) * uhat_validation / sum(abs(uhat_validation), na.rm = T)
```

```{r MASE validation}
mase_validation <- apply(
    X = qhat_validation %>% select(-Year),
    FUN = mean,
    MARGIN = 2,
    na.rm = T
  )
```

```{r dim check validation MASE array}
mase_validation %>% length
```

### Comparison Table:

```{r prettyprint MASEs comparison table}
#| tbl-cap: "Naïve forecasts training and MAPEs for the first 10 time series."

tibble(
  "Time Series Identifier" = mase_training[1:10] %>% names(),
  "Training MASE" = mase_training[1:10],
  "Validation MASE" = mase_validation[1:10]
)
```

## MAPE & MASE Pairs

> *Create a scatter plot of the MAPE pairs, with the training MAPE on the x-axis and the validation MAPE on the y-axis. Create a similar scatter plot for the MASE pairs. Now examine both plots. What do we learn? How does performance differ between the training and validation periods? How does performance range across series?*

```{r MAPE scatterplot}
#| fig-width: 12
#| fig-height: 10
#| fig-cap: "Scatterplot of training and validation MAPE pairs: on both axis, the distribution of values. The time series have been colored using the same mapping seen in @fig-every."
ggplot(
  data = tibble(
    Training_MAPE = mape_training,
    Validation_MAPE = mape_validation,
    Series_Identifier = names(mape_training)
  ),
  aes(
    x = Training_MAPE,
    y = Validation_MAPE,
  color = Series_Identifier
  ),
) + geom_point(
  alpha = .8
) +
  geom_rug() +
  labs(
    title = "Training and Validation MAPE pairs, colored by series",
    x = "Training MAPE",
    y = "Validation MAPE"
  ) + 
  scale_color_viridis_d(
    option = "cividis"
  ) +
  ggthemes::theme_tufte(
    base_size = 16,
    base_family = "Atkinson Hyperlegible",
    ticks = F
  ) +
  theme(
    legend.position = "none"
  )
```

```{r MASE scatterplot}
#| fig-width: 10
#| fig-height: 7
#| fig-cap: "Scatterplot of training and validation MASE pairs: on both axis, the distribution of values. The time series have been colored using the same mapping seen in @fig-every."
#| label: fig-mase
ggplot(
  data = tibble(
    Training_MASE = mase_training,
    Validation_MASE = mase_validation,
    Series_Identifier = names(mase_training)
  ),
  aes(
    x = Training_MASE,
    y = Validation_MASE,
  color = Series_Identifier
  ),
) + geom_point(
  alpha = .8
) +
  geom_rug() +
  labs(
    title = "Training and Validation MASE pairs, colored by series",
    x = "Training MASE",
    y = "Validation MASE"
  ) + 
  scale_color_viridis_d(
    option = "cividis"
  ) +
  ggthemes::theme_tufte(
    base_size = 16,
    base_family = "Atkinson Hyperlegible",
    ticks = F
  ) +
  theme(
    legend.position = "none"
  )
```
Most of the pairs cluster around (0,0), with some notable outliers.

We can filter out these outliers in the MASE training/validation pair to "zoom in" the area in which most of them are clustering:

```{r}
#| fig-width: 12
#| fig-height: 10
#| fig-cap: "Scatterplot of all MASE pairs, as in @fig-mase, with outlier exceeding 3/2 times the IQR filtered out."
ggplot(
  data = tibble(
    Training_MASE = mase_training,
    Validation_MASE = mase_validation,
    Series_Identifier = names(mase_training)
  ) %>% filter(
    Training_MASE <= 3/2*quantile(Training_MASE, probs = .75) &
    Training_MASE >= 3/2*quantile(Training_MASE, probs = .25) &
    Validation_MASE <= 3/2*quantile(Training_MASE, probs = .75) &
    Validation_MASE >= 3/2*quantile(Training_MASE, probs = .25) 
  ),
  aes(
    x = Training_MASE,
    y = Validation_MASE,
  color = Series_Identifier
  ),
) + geom_point(
  alpha = .8
) +
  geom_rug() +
  labs(
    title = "Training and Validation MASE pairs, colored by series",
    x = "Training MASE",
    y = "Validation MASE"
  ) + 
  scale_color_viridis_d(
    option = "cividis"
  ) +
  ggthemes::theme_tufte(
    base_size = 16,
    base_family = "Atkinson Hyperlegible",
    ticks = F
  ) +
  theme(
    legend.position = "none",
    plot.margin = margin(0, 1, 0, 0, "cm")
  )
```

## Ensemble Methods

> *The competition winner, Lee Baker, used an ensemble of three methods:*
>
> -   *Naive forecasts multiplied by a constant trend*[^1].
> -   Linear regression.
> -   Exponentially-weighted linear regression.

[^1]: Global/local trend: "globally tourism has grown"at a rate of 6% annually."

### a. *Write the exact formula used for generating the first method, in the form* $F_{t+k} = ... (k = 1, 2, 3, 4)$, {.unnumbered}

### b. *What is the rational behind multiplying the naive forecasts by a constant?*[^2] {.unnumbered}

[^2]: Hint: think empirical and domain knowledge.

### c. *What should be the dependent variable and the predictors in a linear regression model for this data? Explain.*. {.unnumbered}

### d. *Fit the linear regression model to the first five series and compute forecast errors for the validation period.* {.unnumbered}

```{r select first 5 series}
train_subset <- train %>% 
  select(
    Y1,
    Y2,
    Y3,
    Y4,
    Y5
  )
```

### e. *Before choosing a linear regression, the winner described the following process:* {.unnumbered}

"I examined fitting a polynomial line to the data and using the line to predict future values. I tried using first through fifth order polynomials to find that the lowest MASE was obtained using a first order polynomial (simple regression line). This best fit line was used to predict future values. I also kept the $R^2$ value of the fit for use in blending the results of the prediction."

> *What are two flaws in this approach?*

### f. *If we were to consider exponential smoothing, what particular type(s) of exponential smoothing are reasonable candidates?* {.unnumbered}

### g. *The winner concludes with possible improvements one being "an investigation into how to come up with a blending ensemble method that doesn't use much manual twerking would also be of benefit". Can you suggest methods or an approach that would lead to easier automation of the ensemble step?* {.unnumbered}

### h. *The competition focused on minimizing the average MAPE of the next four values across all 518 series. How does this goal differ from goals encountered in practice when considering tourism demand? Which steps in the forecasting process would likely be different in a real-life tourism forecasting scenario?* {.unnumbered}
